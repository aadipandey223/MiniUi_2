# P2P File Transfer System - Complete Documentation
## Secure, Private, OS-Focused Implementation

**Team Members:**
- **AP (Aadi Pandey)** - Project Lead, UI/UX & Integration
- **RD** - Backend Architecture & WebRTC Implementation
- **AB** - Queue Management & Scheduling Algorithms
- **VU** - Performance Monitoring & Testing

**Project Repository:** github.com/aadipandey223/MiniUi_2  
**Live Demo:** [Railway Deployment URL]

---

# TABLE OF CONTENTS

1. [Project Overview](#project-overview)
2. [Core Features](#core-features)
3. [OS Concepts Demonstrated](#os-concepts)
4. [Privacy & Security Features](#privacy-security)
5. [Revolutionary Cryptography](#cryptography)
6. [User Identity System](#user-identity)
7. [Technical Architecture](#architecture)
8. [Implementation Guide](#implementation)
9. [UI/UX Design](#ui-design)
10. [Market Differentiation](#differentiation)
11. [Demo Script & Questions](#demo)
12. [Future Enhancements](#future)

---

<a name="project-overview"></a>
# 1. PROJECT OVERVIEW

## What It Is
A **peer-to-peer file sharing web application** that enables direct browser-to-browser file transfers without central server storage, featuring military-grade encryption, private rooms, and advanced OS concepts demonstration.

## Key Innovation
Unlike traditional P2P systems, our implementation uses **Triple-Layer Encryption** with quantum-resistant elements and anonymous identity verification - features not found in any commercial product.

## Core Philosophy
- **Privacy First:** Files never touch the server
- **OS Focused:** Every feature demonstrates OS concepts
- **Market Leading:** Security features beyond commercial solutions
- **Production Ready:** Deployable, scalable, maintainable

---

<a name="core-features"></a>
# 2. CORE FEATURES

## 2.1 Basic P2P Transfer
- Direct browser-to-browser file sharing
- WebRTC DataChannel for transfer
- No server storage required
- File chunking (16KB blocks)
- Real-time progress tracking

## 2.2 Private Room System
- Link-based room access
- Room isolation (complete peer separation)
- Password protection
- Temporary/permanent rooms
- QR code sharing for mobile

## 2.3 Advanced Queue Management
- Semaphore-based connection limiting (max 3)
- FCFS (First Come First Serve) scheduling
- Priority queue override
- Auto-processing on slot availability
- Queue wait time tracking

## 2.4 Performance Monitoring
- Real-time network speed graphs
- Connection pool visualization
- Throughput calculation
- Memory usage tracking
- Success/failure statistics

## 2.5 User Identity System (NEW)
- Customizable display names
- Anonymous identity hashing
- Profile customization
- Peer recognition across sessions
- Cool name effects and animations

## 2.6 Revolutionary Cryptography (NEW)
- Triple-layer encryption
- Quantum-resistant algorithms
- Perfect forward secrecy
- Zero-knowledge proof verification
- Blockchain-inspired key distribution

---

<a name="os-concepts"></a>
# 3. OS CONCEPTS DEMONSTRATED

## 3.1 Process Management
**Implementation:** Node.js event loop
- Single-threaded async I/O
- Multiple concurrent transfers
- Process state tracking (running/queued/completed)

**Demo:** Show `ps aux | grep node` to display actual OS process

## 3.2 Semaphores
**Implementation:** Connection limiting
```javascript
let semaphore = 3; // Max concurrent connections

function acquireSemaphore() {
  if (semaphore > 0) {
    semaphore--;
    return true;
  }
  return false; // Queue the request
}

function releaseSemaphore() {
  semaphore++;
  processQueue(); // Start next in queue
}
```

**Visual:** UI shows "2/3 Active" - real semaphore state

## 3.3 Scheduling Algorithms
**FCFS (First Come First Serve):**
```javascript
queue.push(file); // Add to end
const next = queue.shift(); // Take from front
```

**Priority Scheduling:**
```javascript
if (file.priority) {
  queue.unshift(file); // Jump to front
} else {
  queue.push(file); // Normal queue
}
```

**Metrics Tracked:**
- Waiting time: Time in queue
- Turnaround time: Request to completion
- Response time: Request to first byte
- Throughput: Files per minute

## 3.4 Inter-Process Communication
**WebSocket (Signaling):**
- TCP-based persistent connection
- Socket.io for bidirectional communication
- OS manages TCP buffers

**WebRTC DataChannel (Transfer):**
- UDP/TCP hybrid
- OS handles packet routing
- SCTP protocol for reliability

**Demo:** Show `netstat -ano | grep 3000` for actual OS sockets

## 3.5 Memory Management
**File Chunking:**
```javascript
const CHUNK_SIZE = 16384; // 16KB
const chunks = [];

// Read file in chunks (don't load all in RAM)
for (let offset = 0; offset < file.size; offset += CHUNK_SIZE) {
  const chunk = file.slice(offset, offset + CHUNK_SIZE);
  chunks.push(chunk);
}
```

**Garbage Collection:**
- Chunks cleared after assembly
- File objects dereferenced
- Browser GC reclaims memory

**Demo:** Show Chrome DevTools Memory Profiler

## 3.6 File System Interaction
**System Calls Used:**
- `stat()` - Get file metadata (size, modified time)
- `open()` - Get file descriptor
- `read()` - Load file contents
- `close()` - Release file descriptor

**Demo:** Show in browser console during file drop

---

<a name="privacy-security"></a>
# 4. PRIVACY & SECURITY FEATURES

## 4.1 Private Room System

### Architecture
```
Global Network
â”œâ”€â”€ Room: abc123 (Isolated)
â”‚   â”œâ”€â”€ Alice
â”‚   â”œâ”€â”€ Bob
â”‚   â””â”€â”€ Can only see each other's files
â”‚
â”œâ”€â”€ Room: xyz789 (Isolated)
â”‚   â”œâ”€â”€ Charlie
â”‚   â””â”€â”€ David
â”‚
â””â”€â”€ Rooms cannot see each other
```

### Room Creation Flow
1. User clicks "Create Private Room"
2. System generates unique Room ID (9 characters)
3. Optional password setting
4. Shareable link generated: `app.com/room/abc123`
5. QR code generated for mobile sharing

### Room Joining Flow
1. User receives link
2. Clicks link â†’ Auto-redirects to room
3. If password protected â†’ Prompt for password
4. If correct â†’ Join room and see peer files
5. If wrong â†’ Access denied

### Room Features
- **Expiration:** Set room lifetime (1hr, 24hr, 7days, forever)
- **Max Peers:** Limit room size
- **Access Log:** Track who joined/left
- **Room Admin:** Creator has special controls

## 4.2 Password Protection

### Two-Layer Security
**Layer 1: Room Password**
- Set during room creation
- Required to join room
- Can be changed by admin
- SHA-256 hashed on server

**Layer 2: File Password (Optional)**
- Per-file encryption password
- Even room members need password to decrypt
- Use case: Extra sensitive files

### Password Verification
```javascript
// Server-side
const hashedPassword = crypto
  .createHash('sha256')
  .update(password)
  .digest('hex');

if (hashedPassword === room.passwordHash) {
  socket.join(roomId);
} else {
  socket.emit('access-denied');
}
```

## 4.3 File-Level Permissions

### Selective Sharing
```
Upload File: report.pdf
â”œâ”€â”€ Share with: â˜‘ Alice
â”œâ”€â”€             â˜‘ Bob
â””â”€â”€             â˜ Charlie (cannot download)
```

### Access Control List (ACL)
```javascript
{
  fileId: 'file123',
  name: 'report.pdf',
  owner: 'Alice',
  permissions: {
    'Bob': ['read', 'download'],
    'Alice': ['read', 'download', 'delete'],
    'Charlie': ['read'] // Can see, can't download
  }
}
```

## 4.4 End-to-End Encryption

### Standard Implementation (AES-256)
```javascript
// Generate room key when creating room
const roomKey = CryptoJS.lib.WordArray.random(256/8);

// Encrypt file chunk
const encrypted = CryptoJS.AES.encrypt(chunk, roomKey);

// Send encrypted chunk
dataChannel.send(encrypted.toString());

// Receiver decrypts
const decrypted = CryptoJS.AES.decrypt(encrypted, roomKey);
```

**Benefit:** Even if intercepted, data is unreadable

---

<a name="cryptography"></a>
# 5. REVOLUTIONARY CRYPTOGRAPHY (UNIQUE FEATURES)

## 5.1 Triple-Layer Encryption System

### Why Triple-Layer?
**Problem with single encryption:**
- If one key compromised â†’ All data exposed
- No protection against man-in-the-middle during key exchange
- Server can potentially decrypt if it knows the key

**Our Solution:** Three independent encryption layers

### Layer 1: Session Encryption (Ephemeral)
**Algorithm:** ChaCha20-Poly1305
**Key Lifetime:** Valid for current session only
**Purpose:** Protect data in transit

```javascript
// Generate unique session key per transfer
const sessionKey = sodium.crypto_secretbox_keygen();

// Encrypt chunk
const nonce = sodium.randombytes_buf(sodium.crypto_secretbox_NONCEBYTES);
const encrypted = sodium.crypto_secretbox_easy(chunk, nonce, sessionKey);
```

**Why ChaCha20?**
- Faster than AES on mobile devices
- Resistant to timing attacks
- Used by Google, Cloudflare

### Layer 2: Room Encryption (Shared Secret)
**Algorithm:** AES-256-GCM
**Key Lifetime:** Room duration
**Purpose:** Isolate rooms cryptographically

```javascript
// Derive room key from room ID + password
const roomKey = await crypto.subtle.deriveKey(
  {
    name: 'PBKDF2',
    salt: roomId,
    iterations: 100000,
    hash: 'SHA-256'
  },
  password,
  { name: 'AES-GCM', length: 256 },
  false,
  ['encrypt', 'decrypt']
);
```

**Why AES-GCM?**
- Authenticated encryption (detects tampering)
- Industry standard
- Hardware acceleration on modern CPUs

### Layer 3: Identity Encryption (Personal)
**Algorithm:** RSA-4096 + ECC (Elliptic Curve)
**Key Lifetime:** User's device
**Purpose:** Verify sender identity, sign chunks

```javascript
// Generate user keypair (stored in browser)
const keypair = await crypto.subtle.generateKey(
  {
    name: 'RSA-OAEP',
    modulusLength: 4096,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: 'SHA-256'
  },
  true,
  ['encrypt', 'decrypt']
);

// Sign chunk with private key
const signature = await crypto.subtle.sign(
  'RSA-PSS',
  privateKey,
  chunk
);
```

**Why RSA-4096?**
- Quantum-resistant (for now)
- Asymmetric = sender can't decrypt what they send
- Future-proof key size

### Complete Encryption Flow
```
Original File Chunk
    â†“
[Layer 3] Sign with user's private key (RSA-4096)
    â†“
[Layer 2] Encrypt with room key (AES-256-GCM)
    â†“
[Layer 1] Encrypt with session key (ChaCha20)
    â†“
Send over WebRTC DataChannel
    â†“
[Layer 1] Decrypt with session key
    â†“
[Layer 2] Decrypt with room key
    â†“
[Layer 3] Verify signature with user's public key
    â†“
Original Chunk Restored
```

**Result:** 
- Even if attacker breaks one layer â†’ Still 2 layers protecting data
- Even if server is compromised â†’ Cannot decrypt (no private keys stored)
- Even if session key leaks â†’ Room key still protects

## 5.2 Quantum-Resistant Key Exchange

### The Quantum Threat
**Problem:** Future quantum computers will break RSA, ECC
**Timeline:** Estimated 10-15 years
**Impact:** All current encryption becomes vulnerable

### Our Solution: Hybrid Approach

**Classic + Post-Quantum:**
```javascript
// Use both classic and quantum-resistant algorithms
const classicKey = await generateRSAKey(); // For now
const quantumKey = await generateKyberKey(); // For future

// Combine keys using XOR
const hybridKey = classicKey.xor(quantumKey);
```

**Post-Quantum Algorithms We Use:**

1. **Kyber (Key Exchange)**
   - NIST selected standard
   - Based on lattice cryptography
   - Quantum computer cannot break

2. **Dilithium (Digital Signatures)**
   - Quantum-resistant signatures
   - Verifies sender identity

**Implementation:**
```javascript
// Generate Kyber keypair
import { kyber512 } from '@noble/post-quantum/kyber';

const aliceKeys = kyber512.keygen();
const bobKeys = kyber512.keygen();

// Alice generates shared secret
const ciphertext = kyber512.encapsulate(bobKeys.publicKey);

// Bob decrypts shared secret
const sharedSecret = kyber512.decapsulate(ciphertext, bobKeys.secretKey);

// Both now have same secret, quantum-safe!
```

**Why This Matters for Your Project:**
- **Unique Feature:** No other P2P app uses quantum-resistant crypto
- **Future-Proof:** Safe even after quantum computers exist
- **Academic Value:** Demonstrates cutting-edge cryptography
- **Impressive:** Shows advanced security knowledge

## 5.3 Perfect Forward Secrecy (PFS)

### What is PFS?
**Problem:** If encryption key compromised â†’ All past messages readable
**Solution:** Generate new key for every session

### Implementation
```javascript
// Every transfer gets unique ephemeral key
function startTransfer(file) {
  const ephemeralKey = generateRandomKey();
  
  // Use this key only for this transfer
  const encrypted = encrypt(file, ephemeralKey);
  
  // After transfer, destroy key
  ephemeralKey = null; // Garbage collected
}
```

**Benefit:**
- Compromise today's key â†’ Yesterday's transfers still safe
- Each file transfer = independent encryption
- Attacker must break each transfer individually

## 5.4 Zero-Knowledge Proof (Room Password Verification)

### Problem with Traditional Password Check
**Bad Approach:**
```javascript
// User sends password to server
socket.emit('join-room', roomId, password);

// Server checks
if (password === correctPassword) {
  allowJoin();
}
```
**Issue:** Server knows your password!

### Zero-Knowledge Approach
**User proves they know password WITHOUT revealing it**

```javascript
// Server sends challenge
socket.on('password-challenge', (challenge) => {
  
  // User computes hash using password + challenge
  const proof = hash(password + challenge);
  
  // Send proof (not password!)
  socket.emit('password-proof', proof);
});

// Server verifies proof
const expectedProof = hash(correctPassword + challenge);
if (proof === expectedProof) {
  allowJoin(); // User knows password, but we never saw it!
}
```

**Benefit:**
- Server never stores actual password
- Network sniffing reveals nothing
- Even server admin can't know passwords

## 5.5 Blockchain-Inspired File Integrity

### File Chunk Verification
**Problem:** How to ensure file wasn't tampered during transfer?

**Solution:** Hash chain (like blockchain)

```javascript
// Sender creates hash chain
const chunks = splitFile(file);
const hashes = [];

// Each chunk hash includes previous hash (chain)
for (let i = 0; i < chunks.length; i++) {
  const prevHash = i > 0 ? hashes[i-1] : '0';
  const chunkHash = hash(chunks[i] + prevHash);
  hashes.push(chunkHash);
}

// Send hash chain to receiver first
socket.emit('hash-chain', hashes);

// Receiver verifies each chunk
for (let i = 0; i < receivedChunks.length; i++) {
  const prevHash = i > 0 ? hashes[i-1] : '0';
  const computedHash = hash(receivedChunks[i] + prevHash);
  
  if (computedHash !== hashes[i]) {
    throw new Error('Chunk tampered! Reject file.');
  }
}
```

**Benefit:**
- If single chunk modified â†’ Entire chain invalidates
- Cannot replace chunks without detection
- Cryptographic proof of file integrity

## 5.6 Steganography Mode (Hidden Files)

### What is Steganography?
Hiding secret data inside innocent-looking data

### Our Implementation
**Feature:** Hide encrypted file inside an image

```javascript
// Hide file inside image
function hideFileInImage(file, coverImage) {
  // Encrypt file first
  const encrypted = encrypt(file);
  
  // Convert to binary
  const bits = toBinary(encrypted);
  
  // Modify least significant bits of image pixels
  const pixels = coverImage.getImageData();
  
  for (let i = 0; i < bits.length; i++) {
    const pixel = pixels[i];
    
    // Modify last bit of red channel
    pixel.r = (pixel.r & 0xFE) | bits[i];
  }
  
  return modifiedImage; // Looks normal, contains hidden file!
}
```

**Use Case:**
- Send sensitive file disguised as vacation photo
- Looks like innocent image
- Only recipient with key can extract hidden file

**Why This Is Unique:**
- No commercial P2P app has this
- Combines cryptography + steganography
- Demonstrates advanced security concepts

---

<a name="user-identity"></a>
# 6. USER IDENTITY SYSTEM

## 6.1 Anonymous Identity with Custom Names

### Problem
- Default peer IDs: "peer_A3F2", "peer_B7D9" (ugly, unmemorable)
- No way to recognize who you're sharing with
- Privacy concern: Don't want to use real name

### Solution: Customizable Anonymous Identity

### Features

#### 1. Display Name Customization
**UI Element:** Clickable name in top bar

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ‘¤ TechWizard   [Edit]     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Click to Edit:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Your Display Name:         â”‚
â”‚  [TechWizard_________]      â”‚
â”‚                             â”‚
â”‚  Choose Style:              â”‚
â”‚  âš¡ Electric                â”‚
â”‚  ğŸ”¥ Fire                    â”‚
â”‚  ğŸŒŠ Water                   â”‚
â”‚  âœ¨ Sparkle                 â”‚
â”‚                             â”‚
â”‚  Preview: âš¡TechWizardâš¡    â”‚
â”‚                             â”‚
â”‚  [Cancel]  [Confirm]        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2. Name Effects (Cool Animations)

**Electric Style:**
```css
.name-electric {
  animation: electric-glow 2s infinite;
  text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
  color: #00ffff;
}

@keyframes electric-glow {
  0%, 100% { text-shadow: 0 0 10px #00ffff; }
  50% { text-shadow: 0 0 30px #00ffff, 0 0 40px #00ffff; }
}
```

**Fire Style:**
```css
.name-fire {
  background: linear-gradient(45deg, #ff0000, #ff7700, #ffff00);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: fire-flicker 1.5s infinite;
}
```

**Sparkle Style:**
```css
.name-sparkle::before,
.name-sparkle::after {
  content: 'âœ¨';
  animation: sparkle 2s infinite;
}

@keyframes sparkle {
  0%, 100% { opacity: 0; transform: scale(0); }
  50% { opacity: 1; transform: scale(1.2); }
}
```

**Water Style:**
```css
.name-water {
  color: #00aaff;
  animation: wave 3s ease-in-out infinite;
}

@keyframes wave {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-3px); }
}
```

#### 3. Name Validation Rules
- **Length:** 3-20 characters
- **Allowed:** Letters, numbers, underscores
- **Blocked:** Profanity, offensive terms
- **Unique:** In current room (optional)

#### 4. Anonymous Hash ID

**Problem:** Two users pick same name
**Solution:** Unique hash appended

```javascript
// Generate unique identifier
function generateUserHash(displayName) {
  const timestamp = Date.now();
  const random = Math.random();
  const combined = displayName + timestamp + random;
  
  // First 6 chars of hash
  const hash = crypto
    .createHash('sha256')
    .update(combined)
    .digest('hex')
    .substring(0, 6);
  
  return hash;
}

// Display format
const displayName = "TechWizard";
const hash = "a3f2b1";
const fullIdentity = `${displayName}#${hash}`;
// Shows as: TechWizard#a3f2b1
```

**Benefits:**
- Unique even if same display name
- Anonymous (hash can't be traced)
- Memorable (name) + Unique (hash)

#### 5. Peer Recognition Across Sessions

**Store Identity in Browser:**
```javascript
// Save to localStorage
localStorage.setItem('userIdentity', JSON.stringify({
  displayName: 'TechWizard',
  hash: 'a3f2b1',
  style: 'electric',
  createdAt: Date.now()
}));

// Load on next visit
const savedIdentity = JSON.parse(localStorage.getItem('userIdentity'));
```

**Benefit:** Same identity when you return

## 6.2 Identity UI Components

### Top Bar Display
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ P22 Transfer                         â”‚
â”‚                                      â”‚
â”‚ ğŸ‘¤ âš¡TechWizard#a3f2b1âš¡  [Edit]    â”‚
â”‚    â””â”€ Click to customize             â”‚
â”‚                                      â”‚
â”‚ ğŸŸ¢ Connected  |  ğŸ‘¥ 6 peers          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Peer List Display
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Peers in Room (6):            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ‘¤ âš¡TechWizard#a3f2b1âš¡ (You) â”‚
â”‚  ğŸ‘¤ ğŸ”¥CodeMaster#b7d932ğŸ”¥       â”‚
â”‚  ğŸ‘¤ ğŸŒŠDataKing#f3a821ğŸŒŠ         â”‚
â”‚  ğŸ‘¤ âœ¨ByteNinja#c92ef1âœ¨        â”‚
â”‚  ğŸ‘¤ Anonymous#d83af2            â”‚
â”‚  ğŸ‘¤ Guest_4821                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### File Transfer Display
```
Downloading: report.pdf
From: ğŸ”¥CodeMaster#b7d932ğŸ”¥
Progress: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 75%
Speed: 2.3 MB/s
```

### Activity Log
```
Recent Activity:
â€¢ ğŸŒŠDataKing joined the room (2 min ago)
â€¢ âš¡TechWizard uploaded file.pdf (5 min ago)
â€¢ ğŸ”¥CodeMaster downloaded data.xlsx (10 min ago)
â€¢ âœ¨ByteNinja left the room (15 min ago)
```

## 6.3 Advanced Identity Features

### 1. Avatar Generation
**Based on username hash:**
```javascript
// Generate unique avatar from hash
function generateAvatar(hash) {
  // Use hash to pick colors, shapes
  const colors = generateColorPalette(hash);
  const shapes = generateGeometricPattern(hash);
  
  // Create SVG avatar
  return createSVGAvatar(colors, shapes);
}
```

**Result:** Each user gets unique geometric avatar

### 2. Reputation System (Optional)
Track user behavior:
```javascript
{
  userId: 'TechWizard#a3f2b1',
  stats: {
    filesShared: 45,
    successfulTransfers: 42,
    failedTransfers: 3,
    reputation: 0.93, // 93% success rate
    trustScore: 'High'
  }
}
```

**Display:**
```
ğŸ‘¤ âš¡TechWizard#a3f2b1âš¡
   â­â­â­â­â­ (93% success rate)
   45 files shared
```

### 3. Status Messages
**Like Discord/Slack:**
```
ğŸ‘¤ âš¡TechWizard#a3f2b1âš¡
   ğŸ’¬ "Sharing project files"
   ğŸŸ¢ Active
```

### 4. Name History
**Track name changes:**
```javascript
nameHistory: [
  { name: 'TechWizard', from: '2024-01-15', to: '2024-02-10' },
  { name: 'CodeMaster', from: '2024-02-10', to: null }
]
```

**Display:**
```
ğŸ‘¤ ğŸ”¥CodeMaster#b7d932ğŸ”¥
   Previously: TechWizard
```

---

<a name="architecture"></a>
# 7. TECHNICAL ARCHITECTURE

## 7.1 System Components

### Frontend (React + Tailwind CSS)
```
public/
â”œâ”€â”€ index.html          # Main HTML file
â”œâ”€â”€ app.js             # React application
â”‚   â”œâ”€â”€ Components
â”‚   â”‚   â”œâ”€â”€ TopBar (Connection status, peers, user identity)
â”‚   â”‚   â”œâ”€â”€ ActiveTransfers (Progress bars, speeds)
â”‚   â”‚   â”œâ”€â”€ Queue (FCFS + Priority visualization)
â”‚   â”‚   â”œâ”€â”€ FileList (Drag-drop, shared files)
â”‚   â”‚   â”œâ”€â”€ PerformanceDashboard (Metrics, graphs)
â”‚   â”‚   â”œâ”€â”€ RoomManager (Create/join rooms)
â”‚   â”‚   â””â”€â”€ IdentityEditor (Name customization)
â”‚   â”œâ”€â”€ Hooks
â”‚   â”‚   â”œâ”€â”€ useWebRTC (P2P connections)
â”‚   â”‚   â”œâ”€â”€ useSocket (Signaling)
â”‚   â”‚   â”œâ”€â”€ useEncryption (Triple-layer crypto)
â”‚   â”‚   â””â”€â”€ useQueue (Scheduling algorithms)
â”‚   â””â”€â”€ Utils
â”‚       â”œâ”€â”€ crypto.js (Encryption functions)
â”‚       â”œâ”€â”€ chunking.js (File splitting)
â”‚       â””â”€â”€ hashing.js (Identity, integrity)
â””â”€â”€ styles.css          # Dark theme, animations
```

### Backend (Node.js + Express + Socket.io)
```
server/
â”œâ”€â”€ server.js           # Main server file
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ rooms.js       # Room management API
â”‚   â”œâ”€â”€ auth.js        # Password verification
â”‚   â””â”€â”€ files.js       # File metadata
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ signaling.js   # WebRTC signaling
â”‚   â”œâ”€â”€ roomService.js # Room CRUD operations
â”‚   â”œâ”€â”€ cryptoService.js # Key generation, verification
â”‚   â””â”€â”€ queueService.js # Server-side queue coordination
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ Room.js        # Room schema
â”‚   â”œâ”€â”€ User.js        # User identity
â”‚   â””â”€â”€ Transfer.js    # Transfer logs
â””â”€â”€ middleware/
    â”œâ”€â”€ auth.js        # Password middleware
    â””â”€â”€ rateLimit.js   # DDoS protection
```

## 7.2 Data Flow

### Complete Transfer Flow
```
1. User A creates private room
   â†“
2. System generates Room ID + encryption keys
   â†“
3. User A shares link with User B
   â†“
4. User B opens link â†’ Joins room
   â†“
5. WebSocket connection established
   â†“
6. Exchange of:
   - Public keys (RSA-4096)
   - Room key (AES-256)
   - Session key (ChaCha20)
   â†“
7. User A selects file â†’ Drag-drops
   â†“
8. File chunked into 16KB pieces
   â†“
9. Each chunk:
   - Signed with A's private key
   - Encrypted with room key
   - Encrypted with session key
   â†“
10. WebRTC DataChannel established
    â†“
11. Encrypted chunks sent directly A â†’ B
    â†“
12. User B receives chunks:
    - Decrypts with session key
    - Decrypts with room key
    - Verifies signature with A's public key
    â†“
13. Chunks reassembled â†’ Original file
    â†“
14. Hash verification (blockchain-style chain)
    â†“
15. Success! File downloaded securely
```

## 7.3 Database Schema

### Rooms Collection
```javascript
{
  roomId: 'abc123xyz',
  createdBy: 'TechWizard#a3f2b1',
  createdAt: ISODate('2024-01-15T10:30:00Z'),
  expiresAt: ISODate('2024-01-16T10:30:00Z'), // 24 hours
  passwordHash: 'sha256hash...',
  encryptionKey: 'encrypted_key_blob',
  maxPeers: 10,
  currentPeers: ['TechWizard#a3f2b1', 'CodeMaster#b7d932'],
  settings: {
    allowGuestAccess: false,
    requirePassword: true,
    enableE2E: true,
    maxFileSize: 5368709120 // 5GB
  },
  activityLog: [
    { timestamp: ISODate(), user: 'TechWizard#a3f2b1', action: 'joined' },
    { timestamp: ISODate(), user: 'CodeMaster#b7d932', action: 'uploaded', file: 'report.pdf' }
  ]
}
```

### Users Collection
```javascript
{
  userId: 'TechWizard#a3f2b1',
  displayName: 'TechWizard',
  hash: 'a3f2b1',
  publicKey: 'RSA_public_key_pem',
  style: 'electric',
  createdAt: ISODate(),
  stats: {
    filesShared: 45,
    filesReceived: 32,
    totalBytesTransferred: 8589934592, // 8GB
    successRate: 0.93
  },
  preferences: {
    theme: 'dark',
    notifications: true,
    defaultRoomExpiry: 86400000 // 24 hours in ms
  }
}
```

### Transfers Collection (Logs)
```javascript
{
  transferId: 'transfer_123',
  roomId: 'abc123xyz',
  fileName: 'report.pdf',
  fileSize: 2359296, // bytes
  sender: 'TechWizard#a3f2